// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'offering_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$OfferingEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() offering,
    required TResult Function(OfferingModel? offeringModelAdd) addOffering,
    required TResult Function(
            OfferingModel? offeringModelUpdate, int? indexUpdate)
        updateOffering,
    required TResult Function(int? index) removeOffering,
    required TResult Function() getOffering,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? offering,
    TResult? Function(OfferingModel? offeringModelAdd)? addOffering,
    TResult? Function(OfferingModel? offeringModelUpdate, int? indexUpdate)?
        updateOffering,
    TResult? Function(int? index)? removeOffering,
    TResult? Function()? getOffering,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? offering,
    TResult Function(OfferingModel? offeringModelAdd)? addOffering,
    TResult Function(OfferingModel? offeringModelUpdate, int? indexUpdate)?
        updateOffering,
    TResult Function(int? index)? removeOffering,
    TResult Function()? getOffering,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Offering value) offering,
    required TResult Function(_AddOffering value) addOffering,
    required TResult Function(_UpdateOffering value) updateOffering,
    required TResult Function(_RemoveOffering value) removeOffering,
    required TResult Function(_GetOffering value) getOffering,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Offering value)? offering,
    TResult? Function(_AddOffering value)? addOffering,
    TResult? Function(_UpdateOffering value)? updateOffering,
    TResult? Function(_RemoveOffering value)? removeOffering,
    TResult? Function(_GetOffering value)? getOffering,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Offering value)? offering,
    TResult Function(_AddOffering value)? addOffering,
    TResult Function(_UpdateOffering value)? updateOffering,
    TResult Function(_RemoveOffering value)? removeOffering,
    TResult Function(_GetOffering value)? getOffering,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OfferingEventCopyWith<$Res> {
  factory $OfferingEventCopyWith(
          OfferingEvent value, $Res Function(OfferingEvent) then) =
      _$OfferingEventCopyWithImpl<$Res, OfferingEvent>;
}

/// @nodoc
class _$OfferingEventCopyWithImpl<$Res, $Val extends OfferingEvent>
    implements $OfferingEventCopyWith<$Res> {
  _$OfferingEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OfferingEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$OfferingImplCopyWith<$Res> {
  factory _$$OfferingImplCopyWith(
          _$OfferingImpl value, $Res Function(_$OfferingImpl) then) =
      __$$OfferingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OfferingImplCopyWithImpl<$Res>
    extends _$OfferingEventCopyWithImpl<$Res, _$OfferingImpl>
    implements _$$OfferingImplCopyWith<$Res> {
  __$$OfferingImplCopyWithImpl(
      _$OfferingImpl _value, $Res Function(_$OfferingImpl) _then)
      : super(_value, _then);

  /// Create a copy of OfferingEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$OfferingImpl implements _Offering {
  const _$OfferingImpl();

  @override
  String toString() {
    return 'OfferingEvent.offering()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OfferingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() offering,
    required TResult Function(OfferingModel? offeringModelAdd) addOffering,
    required TResult Function(
            OfferingModel? offeringModelUpdate, int? indexUpdate)
        updateOffering,
    required TResult Function(int? index) removeOffering,
    required TResult Function() getOffering,
  }) {
    return offering();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? offering,
    TResult? Function(OfferingModel? offeringModelAdd)? addOffering,
    TResult? Function(OfferingModel? offeringModelUpdate, int? indexUpdate)?
        updateOffering,
    TResult? Function(int? index)? removeOffering,
    TResult? Function()? getOffering,
  }) {
    return offering?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? offering,
    TResult Function(OfferingModel? offeringModelAdd)? addOffering,
    TResult Function(OfferingModel? offeringModelUpdate, int? indexUpdate)?
        updateOffering,
    TResult Function(int? index)? removeOffering,
    TResult Function()? getOffering,
    required TResult orElse(),
  }) {
    if (offering != null) {
      return offering();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Offering value) offering,
    required TResult Function(_AddOffering value) addOffering,
    required TResult Function(_UpdateOffering value) updateOffering,
    required TResult Function(_RemoveOffering value) removeOffering,
    required TResult Function(_GetOffering value) getOffering,
  }) {
    return offering(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Offering value)? offering,
    TResult? Function(_AddOffering value)? addOffering,
    TResult? Function(_UpdateOffering value)? updateOffering,
    TResult? Function(_RemoveOffering value)? removeOffering,
    TResult? Function(_GetOffering value)? getOffering,
  }) {
    return offering?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Offering value)? offering,
    TResult Function(_AddOffering value)? addOffering,
    TResult Function(_UpdateOffering value)? updateOffering,
    TResult Function(_RemoveOffering value)? removeOffering,
    TResult Function(_GetOffering value)? getOffering,
    required TResult orElse(),
  }) {
    if (offering != null) {
      return offering(this);
    }
    return orElse();
  }
}

abstract class _Offering implements OfferingEvent {
  const factory _Offering() = _$OfferingImpl;
}

/// @nodoc
abstract class _$$AddOfferingImplCopyWith<$Res> {
  factory _$$AddOfferingImplCopyWith(
          _$AddOfferingImpl value, $Res Function(_$AddOfferingImpl) then) =
      __$$AddOfferingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({OfferingModel? offeringModelAdd});

  $OfferingModelCopyWith<$Res>? get offeringModelAdd;
}

/// @nodoc
class __$$AddOfferingImplCopyWithImpl<$Res>
    extends _$OfferingEventCopyWithImpl<$Res, _$AddOfferingImpl>
    implements _$$AddOfferingImplCopyWith<$Res> {
  __$$AddOfferingImplCopyWithImpl(
      _$AddOfferingImpl _value, $Res Function(_$AddOfferingImpl) _then)
      : super(_value, _then);

  /// Create a copy of OfferingEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offeringModelAdd = freezed,
  }) {
    return _then(_$AddOfferingImpl(
      offeringModelAdd: freezed == offeringModelAdd
          ? _value.offeringModelAdd
          : offeringModelAdd // ignore: cast_nullable_to_non_nullable
              as OfferingModel?,
    ));
  }

  /// Create a copy of OfferingEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OfferingModelCopyWith<$Res>? get offeringModelAdd {
    if (_value.offeringModelAdd == null) {
      return null;
    }

    return $OfferingModelCopyWith<$Res>(_value.offeringModelAdd!, (value) {
      return _then(_value.copyWith(offeringModelAdd: value));
    });
  }
}

/// @nodoc

class _$AddOfferingImpl implements _AddOffering {
  const _$AddOfferingImpl({this.offeringModelAdd});

  @override
  final OfferingModel? offeringModelAdd;

  @override
  String toString() {
    return 'OfferingEvent.addOffering(offeringModelAdd: $offeringModelAdd)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddOfferingImpl &&
            (identical(other.offeringModelAdd, offeringModelAdd) ||
                other.offeringModelAdd == offeringModelAdd));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offeringModelAdd);

  /// Create a copy of OfferingEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddOfferingImplCopyWith<_$AddOfferingImpl> get copyWith =>
      __$$AddOfferingImplCopyWithImpl<_$AddOfferingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() offering,
    required TResult Function(OfferingModel? offeringModelAdd) addOffering,
    required TResult Function(
            OfferingModel? offeringModelUpdate, int? indexUpdate)
        updateOffering,
    required TResult Function(int? index) removeOffering,
    required TResult Function() getOffering,
  }) {
    return addOffering(offeringModelAdd);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? offering,
    TResult? Function(OfferingModel? offeringModelAdd)? addOffering,
    TResult? Function(OfferingModel? offeringModelUpdate, int? indexUpdate)?
        updateOffering,
    TResult? Function(int? index)? removeOffering,
    TResult? Function()? getOffering,
  }) {
    return addOffering?.call(offeringModelAdd);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? offering,
    TResult Function(OfferingModel? offeringModelAdd)? addOffering,
    TResult Function(OfferingModel? offeringModelUpdate, int? indexUpdate)?
        updateOffering,
    TResult Function(int? index)? removeOffering,
    TResult Function()? getOffering,
    required TResult orElse(),
  }) {
    if (addOffering != null) {
      return addOffering(offeringModelAdd);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Offering value) offering,
    required TResult Function(_AddOffering value) addOffering,
    required TResult Function(_UpdateOffering value) updateOffering,
    required TResult Function(_RemoveOffering value) removeOffering,
    required TResult Function(_GetOffering value) getOffering,
  }) {
    return addOffering(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Offering value)? offering,
    TResult? Function(_AddOffering value)? addOffering,
    TResult? Function(_UpdateOffering value)? updateOffering,
    TResult? Function(_RemoveOffering value)? removeOffering,
    TResult? Function(_GetOffering value)? getOffering,
  }) {
    return addOffering?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Offering value)? offering,
    TResult Function(_AddOffering value)? addOffering,
    TResult Function(_UpdateOffering value)? updateOffering,
    TResult Function(_RemoveOffering value)? removeOffering,
    TResult Function(_GetOffering value)? getOffering,
    required TResult orElse(),
  }) {
    if (addOffering != null) {
      return addOffering(this);
    }
    return orElse();
  }
}

abstract class _AddOffering implements OfferingEvent {
  const factory _AddOffering({final OfferingModel? offeringModelAdd}) =
      _$AddOfferingImpl;

  OfferingModel? get offeringModelAdd;

  /// Create a copy of OfferingEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddOfferingImplCopyWith<_$AddOfferingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateOfferingImplCopyWith<$Res> {
  factory _$$UpdateOfferingImplCopyWith(_$UpdateOfferingImpl value,
          $Res Function(_$UpdateOfferingImpl) then) =
      __$$UpdateOfferingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({OfferingModel? offeringModelUpdate, int? indexUpdate});

  $OfferingModelCopyWith<$Res>? get offeringModelUpdate;
}

/// @nodoc
class __$$UpdateOfferingImplCopyWithImpl<$Res>
    extends _$OfferingEventCopyWithImpl<$Res, _$UpdateOfferingImpl>
    implements _$$UpdateOfferingImplCopyWith<$Res> {
  __$$UpdateOfferingImplCopyWithImpl(
      _$UpdateOfferingImpl _value, $Res Function(_$UpdateOfferingImpl) _then)
      : super(_value, _then);

  /// Create a copy of OfferingEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offeringModelUpdate = freezed,
    Object? indexUpdate = freezed,
  }) {
    return _then(_$UpdateOfferingImpl(
      offeringModelUpdate: freezed == offeringModelUpdate
          ? _value.offeringModelUpdate
          : offeringModelUpdate // ignore: cast_nullable_to_non_nullable
              as OfferingModel?,
      indexUpdate: freezed == indexUpdate
          ? _value.indexUpdate
          : indexUpdate // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of OfferingEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OfferingModelCopyWith<$Res>? get offeringModelUpdate {
    if (_value.offeringModelUpdate == null) {
      return null;
    }

    return $OfferingModelCopyWith<$Res>(_value.offeringModelUpdate!, (value) {
      return _then(_value.copyWith(offeringModelUpdate: value));
    });
  }
}

/// @nodoc

class _$UpdateOfferingImpl implements _UpdateOffering {
  const _$UpdateOfferingImpl({this.offeringModelUpdate, this.indexUpdate});

  @override
  final OfferingModel? offeringModelUpdate;
  @override
  final int? indexUpdate;

  @override
  String toString() {
    return 'OfferingEvent.updateOffering(offeringModelUpdate: $offeringModelUpdate, indexUpdate: $indexUpdate)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateOfferingImpl &&
            (identical(other.offeringModelUpdate, offeringModelUpdate) ||
                other.offeringModelUpdate == offeringModelUpdate) &&
            (identical(other.indexUpdate, indexUpdate) ||
                other.indexUpdate == indexUpdate));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, offeringModelUpdate, indexUpdate);

  /// Create a copy of OfferingEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateOfferingImplCopyWith<_$UpdateOfferingImpl> get copyWith =>
      __$$UpdateOfferingImplCopyWithImpl<_$UpdateOfferingImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() offering,
    required TResult Function(OfferingModel? offeringModelAdd) addOffering,
    required TResult Function(
            OfferingModel? offeringModelUpdate, int? indexUpdate)
        updateOffering,
    required TResult Function(int? index) removeOffering,
    required TResult Function() getOffering,
  }) {
    return updateOffering(offeringModelUpdate, indexUpdate);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? offering,
    TResult? Function(OfferingModel? offeringModelAdd)? addOffering,
    TResult? Function(OfferingModel? offeringModelUpdate, int? indexUpdate)?
        updateOffering,
    TResult? Function(int? index)? removeOffering,
    TResult? Function()? getOffering,
  }) {
    return updateOffering?.call(offeringModelUpdate, indexUpdate);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? offering,
    TResult Function(OfferingModel? offeringModelAdd)? addOffering,
    TResult Function(OfferingModel? offeringModelUpdate, int? indexUpdate)?
        updateOffering,
    TResult Function(int? index)? removeOffering,
    TResult Function()? getOffering,
    required TResult orElse(),
  }) {
    if (updateOffering != null) {
      return updateOffering(offeringModelUpdate, indexUpdate);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Offering value) offering,
    required TResult Function(_AddOffering value) addOffering,
    required TResult Function(_UpdateOffering value) updateOffering,
    required TResult Function(_RemoveOffering value) removeOffering,
    required TResult Function(_GetOffering value) getOffering,
  }) {
    return updateOffering(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Offering value)? offering,
    TResult? Function(_AddOffering value)? addOffering,
    TResult? Function(_UpdateOffering value)? updateOffering,
    TResult? Function(_RemoveOffering value)? removeOffering,
    TResult? Function(_GetOffering value)? getOffering,
  }) {
    return updateOffering?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Offering value)? offering,
    TResult Function(_AddOffering value)? addOffering,
    TResult Function(_UpdateOffering value)? updateOffering,
    TResult Function(_RemoveOffering value)? removeOffering,
    TResult Function(_GetOffering value)? getOffering,
    required TResult orElse(),
  }) {
    if (updateOffering != null) {
      return updateOffering(this);
    }
    return orElse();
  }
}

abstract class _UpdateOffering implements OfferingEvent {
  const factory _UpdateOffering(
      {final OfferingModel? offeringModelUpdate,
      final int? indexUpdate}) = _$UpdateOfferingImpl;

  OfferingModel? get offeringModelUpdate;
  int? get indexUpdate;

  /// Create a copy of OfferingEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateOfferingImplCopyWith<_$UpdateOfferingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RemoveOfferingImplCopyWith<$Res> {
  factory _$$RemoveOfferingImplCopyWith(_$RemoveOfferingImpl value,
          $Res Function(_$RemoveOfferingImpl) then) =
      __$$RemoveOfferingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int? index});
}

/// @nodoc
class __$$RemoveOfferingImplCopyWithImpl<$Res>
    extends _$OfferingEventCopyWithImpl<$Res, _$RemoveOfferingImpl>
    implements _$$RemoveOfferingImplCopyWith<$Res> {
  __$$RemoveOfferingImplCopyWithImpl(
      _$RemoveOfferingImpl _value, $Res Function(_$RemoveOfferingImpl) _then)
      : super(_value, _then);

  /// Create a copy of OfferingEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = freezed,
  }) {
    return _then(_$RemoveOfferingImpl(
      index: freezed == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$RemoveOfferingImpl implements _RemoveOffering {
  const _$RemoveOfferingImpl({this.index});

  @override
  final int? index;

  @override
  String toString() {
    return 'OfferingEvent.removeOffering(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RemoveOfferingImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  /// Create a copy of OfferingEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RemoveOfferingImplCopyWith<_$RemoveOfferingImpl> get copyWith =>
      __$$RemoveOfferingImplCopyWithImpl<_$RemoveOfferingImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() offering,
    required TResult Function(OfferingModel? offeringModelAdd) addOffering,
    required TResult Function(
            OfferingModel? offeringModelUpdate, int? indexUpdate)
        updateOffering,
    required TResult Function(int? index) removeOffering,
    required TResult Function() getOffering,
  }) {
    return removeOffering(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? offering,
    TResult? Function(OfferingModel? offeringModelAdd)? addOffering,
    TResult? Function(OfferingModel? offeringModelUpdate, int? indexUpdate)?
        updateOffering,
    TResult? Function(int? index)? removeOffering,
    TResult? Function()? getOffering,
  }) {
    return removeOffering?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? offering,
    TResult Function(OfferingModel? offeringModelAdd)? addOffering,
    TResult Function(OfferingModel? offeringModelUpdate, int? indexUpdate)?
        updateOffering,
    TResult Function(int? index)? removeOffering,
    TResult Function()? getOffering,
    required TResult orElse(),
  }) {
    if (removeOffering != null) {
      return removeOffering(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Offering value) offering,
    required TResult Function(_AddOffering value) addOffering,
    required TResult Function(_UpdateOffering value) updateOffering,
    required TResult Function(_RemoveOffering value) removeOffering,
    required TResult Function(_GetOffering value) getOffering,
  }) {
    return removeOffering(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Offering value)? offering,
    TResult? Function(_AddOffering value)? addOffering,
    TResult? Function(_UpdateOffering value)? updateOffering,
    TResult? Function(_RemoveOffering value)? removeOffering,
    TResult? Function(_GetOffering value)? getOffering,
  }) {
    return removeOffering?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Offering value)? offering,
    TResult Function(_AddOffering value)? addOffering,
    TResult Function(_UpdateOffering value)? updateOffering,
    TResult Function(_RemoveOffering value)? removeOffering,
    TResult Function(_GetOffering value)? getOffering,
    required TResult orElse(),
  }) {
    if (removeOffering != null) {
      return removeOffering(this);
    }
    return orElse();
  }
}

abstract class _RemoveOffering implements OfferingEvent {
  const factory _RemoveOffering({final int? index}) = _$RemoveOfferingImpl;

  int? get index;

  /// Create a copy of OfferingEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RemoveOfferingImplCopyWith<_$RemoveOfferingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GetOfferingImplCopyWith<$Res> {
  factory _$$GetOfferingImplCopyWith(
          _$GetOfferingImpl value, $Res Function(_$GetOfferingImpl) then) =
      __$$GetOfferingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetOfferingImplCopyWithImpl<$Res>
    extends _$OfferingEventCopyWithImpl<$Res, _$GetOfferingImpl>
    implements _$$GetOfferingImplCopyWith<$Res> {
  __$$GetOfferingImplCopyWithImpl(
      _$GetOfferingImpl _value, $Res Function(_$GetOfferingImpl) _then)
      : super(_value, _then);

  /// Create a copy of OfferingEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$GetOfferingImpl implements _GetOffering {
  const _$GetOfferingImpl();

  @override
  String toString() {
    return 'OfferingEvent.getOffering()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetOfferingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() offering,
    required TResult Function(OfferingModel? offeringModelAdd) addOffering,
    required TResult Function(
            OfferingModel? offeringModelUpdate, int? indexUpdate)
        updateOffering,
    required TResult Function(int? index) removeOffering,
    required TResult Function() getOffering,
  }) {
    return getOffering();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? offering,
    TResult? Function(OfferingModel? offeringModelAdd)? addOffering,
    TResult? Function(OfferingModel? offeringModelUpdate, int? indexUpdate)?
        updateOffering,
    TResult? Function(int? index)? removeOffering,
    TResult? Function()? getOffering,
  }) {
    return getOffering?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? offering,
    TResult Function(OfferingModel? offeringModelAdd)? addOffering,
    TResult Function(OfferingModel? offeringModelUpdate, int? indexUpdate)?
        updateOffering,
    TResult Function(int? index)? removeOffering,
    TResult Function()? getOffering,
    required TResult orElse(),
  }) {
    if (getOffering != null) {
      return getOffering();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Offering value) offering,
    required TResult Function(_AddOffering value) addOffering,
    required TResult Function(_UpdateOffering value) updateOffering,
    required TResult Function(_RemoveOffering value) removeOffering,
    required TResult Function(_GetOffering value) getOffering,
  }) {
    return getOffering(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Offering value)? offering,
    TResult? Function(_AddOffering value)? addOffering,
    TResult? Function(_UpdateOffering value)? updateOffering,
    TResult? Function(_RemoveOffering value)? removeOffering,
    TResult? Function(_GetOffering value)? getOffering,
  }) {
    return getOffering?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Offering value)? offering,
    TResult Function(_AddOffering value)? addOffering,
    TResult Function(_UpdateOffering value)? updateOffering,
    TResult Function(_RemoveOffering value)? removeOffering,
    TResult Function(_GetOffering value)? getOffering,
    required TResult orElse(),
  }) {
    if (getOffering != null) {
      return getOffering(this);
    }
    return orElse();
  }
}

abstract class _GetOffering implements OfferingEvent {
  const factory _GetOffering() = _$GetOfferingImpl;
}

/// @nodoc
mixin _$OfferingState {
  OfferingStatus get status => throw _privateConstructorUsedError;
  String get error => throw _privateConstructorUsedError;
  OfferingModel? get offeringModel => throw _privateConstructorUsedError;
  List<OfferingModel> get offeringList => throw _privateConstructorUsedError;

  /// Create a copy of OfferingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OfferingStateCopyWith<OfferingState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OfferingStateCopyWith<$Res> {
  factory $OfferingStateCopyWith(
          OfferingState value, $Res Function(OfferingState) then) =
      _$OfferingStateCopyWithImpl<$Res, OfferingState>;
  @useResult
  $Res call(
      {OfferingStatus status,
      String error,
      OfferingModel? offeringModel,
      List<OfferingModel> offeringList});

  $OfferingModelCopyWith<$Res>? get offeringModel;
}

/// @nodoc
class _$OfferingStateCopyWithImpl<$Res, $Val extends OfferingState>
    implements $OfferingStateCopyWith<$Res> {
  _$OfferingStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OfferingState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
    Object? error = null,
    Object? offeringModel = freezed,
    Object? offeringList = null,
  }) {
    return _then(_value.copyWith(
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as OfferingStatus,
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
      offeringModel: freezed == offeringModel
          ? _value.offeringModel
          : offeringModel // ignore: cast_nullable_to_non_nullable
              as OfferingModel?,
      offeringList: null == offeringList
          ? _value.offeringList
          : offeringList // ignore: cast_nullable_to_non_nullable
              as List<OfferingModel>,
    ) as $Val);
  }

  /// Create a copy of OfferingState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OfferingModelCopyWith<$Res>? get offeringModel {
    if (_value.offeringModel == null) {
      return null;
    }

    return $OfferingModelCopyWith<$Res>(_value.offeringModel!, (value) {
      return _then(_value.copyWith(offeringModel: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$OfferingStateImplCopyWith<$Res>
    implements $OfferingStateCopyWith<$Res> {
  factory _$$OfferingStateImplCopyWith(
          _$OfferingStateImpl value, $Res Function(_$OfferingStateImpl) then) =
      __$$OfferingStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {OfferingStatus status,
      String error,
      OfferingModel? offeringModel,
      List<OfferingModel> offeringList});

  @override
  $OfferingModelCopyWith<$Res>? get offeringModel;
}

/// @nodoc
class __$$OfferingStateImplCopyWithImpl<$Res>
    extends _$OfferingStateCopyWithImpl<$Res, _$OfferingStateImpl>
    implements _$$OfferingStateImplCopyWith<$Res> {
  __$$OfferingStateImplCopyWithImpl(
      _$OfferingStateImpl _value, $Res Function(_$OfferingStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of OfferingState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
    Object? error = null,
    Object? offeringModel = freezed,
    Object? offeringList = null,
  }) {
    return _then(_$OfferingStateImpl(
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as OfferingStatus,
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
      offeringModel: freezed == offeringModel
          ? _value.offeringModel
          : offeringModel // ignore: cast_nullable_to_non_nullable
              as OfferingModel?,
      offeringList: null == offeringList
          ? _value._offeringList
          : offeringList // ignore: cast_nullable_to_non_nullable
              as List<OfferingModel>,
    ));
  }
}

/// @nodoc

class _$OfferingStateImpl implements _OfferingState {
  const _$OfferingStateImpl(
      {this.status = OfferingStatus.initial,
      this.error = '',
      this.offeringModel,
      final List<OfferingModel> offeringList = const []})
      : _offeringList = offeringList;

  @override
  @JsonKey()
  final OfferingStatus status;
  @override
  @JsonKey()
  final String error;
  @override
  final OfferingModel? offeringModel;
  final List<OfferingModel> _offeringList;
  @override
  @JsonKey()
  List<OfferingModel> get offeringList {
    if (_offeringList is EqualUnmodifiableListView) return _offeringList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_offeringList);
  }

  @override
  String toString() {
    return 'OfferingState(status: $status, error: $error, offeringModel: $offeringModel, offeringList: $offeringList)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OfferingStateImpl &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.offeringModel, offeringModel) ||
                other.offeringModel == offeringModel) &&
            const DeepCollectionEquality()
                .equals(other._offeringList, _offeringList));
  }

  @override
  int get hashCode => Object.hash(runtimeType, status, error, offeringModel,
      const DeepCollectionEquality().hash(_offeringList));

  /// Create a copy of OfferingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OfferingStateImplCopyWith<_$OfferingStateImpl> get copyWith =>
      __$$OfferingStateImplCopyWithImpl<_$OfferingStateImpl>(this, _$identity);
}

abstract class _OfferingState implements OfferingState {
  const factory _OfferingState(
      {final OfferingStatus status,
      final String error,
      final OfferingModel? offeringModel,
      final List<OfferingModel> offeringList}) = _$OfferingStateImpl;

  @override
  OfferingStatus get status;
  @override
  String get error;
  @override
  OfferingModel? get offeringModel;
  @override
  List<OfferingModel> get offeringList;

  /// Create a copy of OfferingState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OfferingStateImplCopyWith<_$OfferingStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
